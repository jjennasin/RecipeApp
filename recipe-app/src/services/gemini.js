const apiKey = process.env.GEMINI_API_KEY;

if (!apiKey) {
  console.error("FATAL: GEMINI_API_KEY environment variable is not set.");
}

const MODEL_NAME = "gemini-2.5-flash-preview-09-2025";
const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${apiKey}`;
const MAX_RETRIES = 3;

const systemInstruction =
  "You are a world-class chef AI. Generate a complete cooking recipe that strictly adheres to the user's request and the provided JSON schema. If the query is just a list of ingredients, create a dish that uses all of them. Do not include any external comments or prose; return only the JSON object.";

const recipeSchema = {
  type: "OBJECT",
  properties: {
    recipe_id: {
      type: "STRING",
      description:
        "A placeholder ID. Use 'TEMP_ID'. The actual unique ID will be generated by the app's backend.",
    },
    title: { type: "STRING" },
    ingredients: {
      type: "ARRAY",
      items: {
        type: "OBJECT",
        properties: {
          name: { type: "STRING" },
          quantity: { type: "STRING" },
        },
      },
    },
    instructions: {
      type: "ARRAY",
      items: { type: "STRING" },
    },
    prep_time_minutes: {
      type: "INTEGER",
    },
    difficulty_level: {
      type: "STRING",
      enum: ["EASY", "MEDIUM", "HARD"],
    },
    estimated_calories: {
      type: "INTEGER",
    },
  },
  required: [
    "title",
    "ingredients",
    "instructions",
    "prep_time_minutes",
    "difficulty_level",
  ],
};

export async function generateRecipe(filters) {
  const actualFilters =
    typeof filters === "string" ? { query: filters } : filters || {};
  const {
    query,
    cuisine,
    maxTimeMinutes,
    dietaryRestrictions,
    difficulty,
    notes,
  } = actualFilters;

  if (!query || query.trim() === "") {
    console.warn("Recipe query is empty.");
    return null;
  }

  const constraintLines = [];
  if (cuisine) constraintLines.push(`Cuisine: ${cuisine}.`);
  if (maxTimeMinutes)
    constraintLines.push(
      `Total time must ensure prep_time_minutes is <= ${maxTimeMinutes} minutes.`
    );
  if (dietaryRestrictions)
    constraintLines.push(
      `Dietary restrictions to respect: ${dietaryRestrictions}.`
    );
  if (difficulty)
    constraintLines.push(`Difficulty level: ${difficulty.toUpperCase()}.`);
  if (notes) constraintLines.push(`Other details: ${notes}.`);

  const constraintsText =
    constraintLines.length > 0
      ? "CONSTRAINTS:\n" + constraintLines.map((l) => `- ${l}`).join("\n")
      : "CONSTRAINTS:\n- None specified.";

  const prompt = `
Create a complete cooking recipe in JSON format based on the user's request.

USER REQUEST: "${query}"

${constraintsText}

RULES:
1. Obey all constraints.
2. The recipe_id field MUST be "TEMP_ID".
3. Return ONLY the JSON object defined by the schema.
`;

  const payload = {
    contents: [{ parts: [{ text: prompt }] }],
    generationConfig: {
      responseMimeType: "application/json",
      responseSchema: recipeSchema,
      temperature: 0.2,
    },
    systemInstruction: { parts: [{ text: systemInstruction }] },
  };

  for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
    try {
      const response = await fetch(API_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });

      const result = await response.json();

      if (
        (response.status === 429 || response.status >= 500) &&
        attempt < MAX_RETRIES - 1
      ) {
        const delay = Math.pow(2, attempt) * 1000 + Math.random() * 500;
        console.warn(
          `API Error (${response.status}). Retrying in ${delay.toFixed(0)}ms...`
        );
        await new Promise((resolve) => setTimeout(resolve, delay));
        continue;
      }

      if (!response.ok) {
        throw new Error(
          `API failed: ${response.status}, body: ${JSON.stringify(result)}`
        );
      }

      let parsed = null;
      const part = result?.candidates?.[0]?.content?.parts?.[0];
      if (part?.jsonValue) {
        parsed = part.jsonValue;
      } else if (part?.text) {
        try {
          parsed = JSON.parse(part.text.trim());
        } catch (err) {
          console.error("Failed to parse raw JSON:", err);
        }
      }

      if (!parsed) {
        console.error("Failed to extract JSON from Gemini response:", result);
        return null;
      }

      return parsed;
    } catch (error) {
      if (attempt < MAX_RETRIES - 1) {
        const delay = Math.pow(2, attempt) * 1000 + Math.random() * 500;
        console.warn(
          `Network error: ${error.message}. Retrying in ${delay.toFixed(
            0
          )}ms...`
        );
        await new Promise((resolve) => setTimeout(resolve, delay));
      } else {
        console.error("Recipe generation failed after max retries.", error);
        throw error;
      }
    }
  }

  return null;
}
