import "dotenv/config";

const apiKey = process.env.GEMINI_API_KEY || "";
const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;
const MAX_RETRIES = 3;

const recipeSchema = {
  type: "OBJECT",
  properties: {
    recipe_id: {
      type: "STRING",
      description:
        "A placeholder ID. The actual unique ID will be generated by the app's backend.",
    },
    title: {
      type: "STRING",
      description: "The name of the recipe.",
    },
    ingredients: {
      type: "ARRAY",
      items: {
        type: "OBJECT",
        properties: {
          name: { type: "STRING" },
          quantity: { type: "STRING" },
        },
      },
    },
    instructions: {
      type: "ARRAY",
      items: { type: "STRING" },
      description: "A step-by-step list of instructions.",
    },
    prep_time_minutes: {
      type: "INTEGER",
      description: "The approximate preparation time in minutes.",
    },
    difficulty_level: {
      type: "STRING",
      enum: ["EASY", "MEDIUM", "HARD"],
    },
    estimated_calories: {
      type: "INTEGER",
      description:
        "The approximate total calorie count for the entire recipe, a calculated guess.",
    },
  },
  required: [
    "title",
    "ingredients",
    "instructions",
    "prep_time_minutes",
    "difficulty_level",
  ],
};

export async function generateRecipe(query) {
  if (!query || query.trim() === "") {
    return null;
  }

  const systemInstruction =
    "You are a world-class chef AI. Generate a complete recipe that strictly adheres to the user's request and the provided JSON schema. If the query is just a list of ingredients, create a dish that uses all of them.";

  const prompt = `Generate a complete recipe based on the following list of ingredients and constraints: "${query}". Ensure the output strictly follows the provided JSON schema. For the recipe_id, use a temporary value like 'TEMP_ID'.`;

  const payload = {
    contents: [{ parts: [{ text: prompt }] }],
    generationConfig: {
      responseMimeType: "application/json",
      responseSchema: recipeSchema,
      temperature: 0.2,
    },
    systemInstruction: { parts: [{ text: systemInstruction }] },
  };

  for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
    try {
      const fetchFunction =
        typeof fetch !== "undefined"
          ? fetch
          : (await import("node-fetch")).default;

      const response = await fetchFunction(API_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });

      if (response.ok) {
        const result = await response.json();
        const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;

        if (jsonText) {
          if (
            jsonText.trim().startsWith("{") &&
            jsonText.trim().endsWith("}")
          ) {
            return JSON.parse(jsonText);
          }
        }

        console.error(
          "Gemini returned OK status but recipe body was empty or malformed."
        );
      }

      if (response.status === 429 && attempt < MAX_RETRIES - 1) {
        const delay = Math.pow(2, attempt) * 1000 + Math.random() * 500;
        console.log(
          `Rate limit hit (429). Retrying in ${delay.toFixed(
            0
          )}ms... (Attempt ${attempt + 2})`
        );
        await new Promise((resolve) => setTimeout(resolve, delay));
        continue;
      }

      const errorMessage = `API request failed with status: ${response.status} ${response.statusText}.`;
      console.error(errorMessage);

      throw new Error(errorMessage);
    } catch (error) {
      if (attempt < MAX_RETRIES - 1) {
        const delay = Math.pow(2, attempt) * 1000 + Math.random() * 500;
        console.warn(
          `Fetch/Network error: ${error.message}. Retrying in ${delay.toFixed(
            0
          )}ms... (Attempt ${attempt + 2})`
        );
        await new Promise((resolve) => setTimeout(resolve, delay));
        continue;
      }
      throw error;
    }
  }

  throw new Error("Recipe generation failed after maximum retries.");
}
