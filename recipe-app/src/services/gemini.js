import "dotenv/config";

const apiKey = process.env.GEMINI_API_KEY || "";
const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;
const MAX_RETRIES = 3;

const recipeSchema = {
  type: "OBJECT",
  properties: {
    recipe_id: {
      type: "STRING",
      description:
        "A placeholder ID. The actual unique ID will be generated by the app's backend.",
    },
    title: {
      type: "STRING",
      description: "The name of the recipe.",
    },
    ingredients: {
      type: "ARRAY",
      items: {
        type: "OBJECT",
        properties: {
          name: { type: "STRING" },
          quantity: { type: "STRING" },
        },
      },
    },
    instructions: {
      type: "ARRAY",
      items: { type: "STRING" },
      description: "A step-by-step list of instructions.",
    },
    prep_time_minutes: {
      type: "INTEGER",
      description: "The approximate preparation time in minutes.",
    },
    difficulty_level: {
      type: "STRING",
      enum: ["EASY", "MEDIUM", "HARD"],
    },
    estimated_calories: {
      type: "INTEGER",
      description:
        "The approximate total calorie count for the entire recipe, a calculated guess.",
    },
  },
  required: [
    "title",
    "ingredients",
    "instructions",
    "prep_time_minutes",
    "difficulty_level",
  ],
};

/**
 * Generates a structured recipe using the Gemini API via the Fetch API.
 * This function handles API call, structure enforcement, and error management with exponential backoff.
 * @param {string} query - The user's query (e.g., "pasta, beef, and onions").
 * @returns {object|null} The generated JSON recipe object.
 */
export async function generateRecipe(query) {
  if (!query || query.trim() === "") {
    return null;
  }

  const systemInstruction =
    "You are a world-class chef AI. Generate a complete recipe that strictly adheres to the user's request and the provided JSON schema. If the query is just a list of ingredients, create a dish that uses all of them.";

  const prompt = `Generate a complete recipe based on the following list of ingredients and constraints: "${query}". Ensure the output strictly follows the provided JSON schema. For the recipe_id, use a temporary value like 'TEMP_ID'.`;

  const payload = {
    contents: [{ parts: [{ text: prompt }] }],
    generationConfig: {
      responseMimeType: "application/json",
      responseSchema: recipeSchema,
      temperature: 0.2,
    },
    systemInstruction: { parts: [{ text: systemInstruction }] },
  };

  for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
    try {
      // Use node-fetch in a local node environment (requires 'node-fetch' dependency)
      // or global fetch in the browser/canvas.
      const fetchFunction =
        typeof fetch !== "undefined"
          ? fetch
          : (await import("node-fetch")).default;

      const response = await fetchFunction(API_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });

      if (response.ok) {
        const result = await response.json();
        const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;

        if (jsonText) {
          // Check for common non-JSON response issues before parsing
          if (
            jsonText.trim().startsWith("{") &&
            jsonText.trim().endsWith("}")
          ) {
            return JSON.parse(jsonText);
          }
        }
      } else if (response.status === 429 && attempt < MAX_RETRIES - 1) {
        // Rate limit error (429), apply exponential backoff
        const delay = Math.pow(2, attempt) * 1000;
        await new Promise((resolve) => setTimeout(resolve, delay));
        continue; // Retry the loop
      }

      console.error(
        `API request failed with status: ${response.status} ${response.statusText}`
      );
      return null;
    } catch (error) {
      console.error(
        "Fetch API error (Is 'node-fetch' installed and is your .env file correct?):",
        error
      );
      if (attempt < MAX_RETRIES - 1) {
        const delay = Math.pow(2, attempt) * 1000;
        await new Promise((resolve) => setTimeout(resolve, delay));
        continue; // Retry the loop
      }
      return null;
    }
  }
  return null; // All retries failed
}
